# schema.graphql
type Token {
  address: String!
  symbol: String!
  chainId: Int!
}

type Chain {
  id: Int!
  name: String!
}

type Coin {
  id: String
  symbol: String
  name: String
  current_price: Float
  market_cap: Float
}

type BridgeTransaction {
  id: ID!
  sourceChainId: Int!
  targetChainId: Int!
  token: String!
  amount: String!
  sender: String!
  recipient: String!
  sourceTxHash: String
  targetTxHash: String
  status: TransactionStatus!
  createdAt: String!
  updatedAt: String!
}

type ApiKey {
  clientName: String!
  isActive: Boolean!
  createdAt: String!
  lastUsed: String
  usageCount: Int!
  rateLimit: Int!
  dailyUsage: Int!
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

type BridgeTokenResponse {
  success: Boolean!
  transactionHash: String
  sourceTxHash: String
  targetTxHash: String
  status: String!
  error: String
}

input ApiKeyInput {
  clientName: String!
  rateLimit: Int!
}

type Query {
  supportedChains: [Chain!]!
  getCoinPrice(id: String): Coin
  getCoinMarketData(id: String, vs_currency: String): Coin
  bridgeTransaction(id: ID!): BridgeTransaction
  bridgeTransactions(
    address: String!
    status: TransactionStatus
  ): [BridgeTransaction!]!
  getApiKeyInfo(key: String!): ApiKey
}
type BridgeRequest {
  token: String!
  sourceChainId: Int!
  targetChainId: Int!
  amount: String!
  sender: String!
  recipient: String!
}

type Mutation {
  generateApiKey(input: ApiKeyInput!): String!
  deactivateApiKey(key: String!): Boolean!
  updateRateLimit(key: String!, newLimit: Int!): Boolean!
  resetApiKey(key: String!): String
  bridgeToken(
    token: String!
    sourceChainId: Int!
    targetChainId: Int!
    amount: String!
    sender: String!
    recipient: String!
  ): BridgeTokenResponse!
}

type Subscription {
  bridgeTransactionUpdated(address: String!): BridgeTransaction!
}
input BridgeTokenInput {
  token: String! # Token address
  sourceChainId: Int! # Source chain ID
  targetChainId: Int! # Target chain ID
  amount: String! # Amount in wei
  sender: String! # Sender address
  recipient: String! # Recipient address
}

type BridgeResponse {
  success: Boolean!
  transactionHash: String
  sourceTxHash: String
  targetTxHash: String
  status: String!
  error: String
  signatures: [String!]
  validatorAddresses: [String!]
}
